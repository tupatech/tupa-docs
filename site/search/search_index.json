{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo ao Tup\u00e3 \u26a1\ufe0f","text":"<p>O Tup\u00e3 \u00e9 um framework backend feito em Go.</p> <p>A ideia do framework \u00e9 ser f\u00e1cil e r\u00e1pido de usar, te ajudando na cria\u00e7\u00e3o de aplica\u00e7\u00f5es robustas feitas rapidamente.</p> <p>O \u00fanico requisito \u00e9 que Golang, vers\u00e3o 1.21.5 para cima esteja instalado na m\u00e1quina.</p>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>Voc\u00ea pode instalar o Tup\u00e3 dentro do seu projeto com o comando:</p> <pre><code>$ go get github.com/tupatech/tupa\n</code></pre>"},{"location":"#iniciando-um-servidor","title":"Iniciando um Servidor","text":"<p>Para iniciarmos um novo servidor, basta instanciarmos um <code>NewAPIServer(\":porta\", nil)</code> e fazer o bootstrap da API com o m\u00e9todo <code>New()</code>. Inicialize o m\u00f3dulo dentro do diret\u00f3rio desejado <code>go mod &lt;nome_modulo&gt;</code>, e coloque o seguinte conte\u00fado num arquivo <code>main.go</code> </p> <pre><code>import (\n    import \"github.com/tupatech/tupa\"\n)\n\nfunc main() {\n    server := tupa.NewAPIServer(\":6969\", nil)\n    server.New()\n}\n</code></pre> <p>Rode o servidor na m\u00e1quina <code>go run main.go</code>. No browser em <code>http://localhost:6969/</code> vamos receber a seguinte mensagem:</p> <pre><code>\"Seja bem vindo ao Tup\u00e3 framework\"\n</code></pre> <p>Criando novas rotas</p>"},{"location":"after_middlewares/","title":"Criando After Middlewares","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Criando After Middleware</li> </ul> <p>Podemos criar After Middlewares espec\u00edficos de rotas, dessa forma, eles ser\u00e3o executados ap\u00f3s os middlewares Globais, de Conjuntos de Rotas, Espec\u00edficos de rotas, Requisi\u00e7\u00e3o, respectivamente. Veja o exemplo abaixo:</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager)\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(nil, SampleRouteManager)\n}\n\nfunc AfterMiddlewareTest(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"AfterMiddlewareTest -&gt; midd after route\")\n        return next(c)\n    }\n}\n\nfunc MiddlewareSampleRoute(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        catsCtxKey := \"ctxcats\"\n        ctxMsg := \"contexto de algu\u00e9m interessado em gatos\"\n\n        slog.Info(\"MiddlewareSampleRoute -&gt; midd especifico rota\")\n\n        newCtx := context.WithValue(c.GetCtx(), catsCtxKey, ctxMsg)\n\n        c.SetContext(newCtx)\n\n        return next(c)\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/param\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                slog.Info(\"hello world\")\n                c.SendString(\"Hello world\")\n\n                return nil\n            },\n            Middlewares:      []tupa.MiddlewareFunc{MiddlewareSampleRoute},\n            AfterMiddlewares: []tupa.MiddlewareFunc{AfterMiddlewareTest},\n        },\n    }\n}\n</code></pre> <p>Dessa forma criamos after middlewares espec\u00edficos de rotas facilmente, e podemos adicionarmos quantos precisarmos em nossa requisi\u00e7\u00e3o.</p>"},{"location":"context/","title":"Context no Tup\u00e3","text":"<p>Voc\u00ea pode acessar o context da requisi\u00e7\u00e3o a partir da propriedade Context dentro da struct do Tupa</p>"},{"location":"context/#context-em-middlewares","title":"Context em Middlewares","text":"<p>Podemos facilmente adicionar contexto a uma requisi\u00e7\u00e3o. No Tup\u00e2 existem v\u00e1rias formas de se trabalhar com o contexto atrav\u00e9s do TupaContext. Por exemplo voc\u00ea pode colocar um novo context com o m\u00e9todo <code>SetContext()</code>, que vai colocar o m\u00e9todo na requisi\u00e7\u00e3o. Para obter o valor do contexto, voc\u00ea pode obter o contexto com os m\u00e9todos <code>GetCtx()</code>, <code>CtxValue(ctx)</code>.</p> <ul> <li><code>GetCtx()</code>: retorna o context inteiro da requisi\u00e7\u00e3o</li> <li><code>CtxValue(ctx)</code>: retorna o contexto espec\u00edfico de acordo com a key especificada</li> </ul> <p>Vamos adicionar um Contexto no middleware MiddlewareSampleRoute(). Lembrando que em primeiro lugar \u00e9 chamado os middlewares especificos de rota, e s\u00f3 ent\u00e3o os globais.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager)\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        return next(tc)\n    }\n}\n\nfunc MiddlewareSampleRoute(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        catsCtxKey := \"ctxcats\"\n        ctxMsg := \"contexto de algu\u00e9m interessado em gatos\"\n        newCtx := context.WithValue(tc.GetCtx(), catsCtxKey, ctxMsg)\n        tc.SetContext(newCtx)\n\n        return next(tc)\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                ctxFull := tc.GetCtx()\n                fmt.Println(ctxFull)\n\n                ctxValue := tc.CtxValue(\"ctxcats\").(string)\n                fmt.Println(ctxValue)\n\n                ctxVal := tc.GetCtx().Value(\"ctxcats\").(string)\n                fmt.Println(ctxVal)\n\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(*tc.Response(), resp.Body)\n                return err\n            },\n            Middlewares: []tupa.MiddlewareFunc{MiddlewareSampleRoute},\n        },\n    }\n}\n\n</code></pre> <p>output:</p> <pre><code>context.Background.WithValue(type *http.contextKey, val &lt;not Stringer&gt;).WithValue(type *http.contextKey, val [::1]:6969).WithCancel.WithCancel.WithValue(type mux.contextKey, val &lt;not Stringer&gt;).WithValue(type mux.contextKey, val &lt;not Stringer&gt;).WithValue(type string, val contexto de algu\u00e9m interessado em gatos)\ncontexto de algu\u00e9m interessado em gatos\ncontexto de algu\u00e9m interessado em gatos\n</code></pre>"},{"location":"contributing/","title":"Guia de contribui\u00e7\u00e3o","text":"<p>Abra uma issue no reposit\u00f3rio do github e envie uma pull-request em uma branch separada. Crie uma branch com o nome da tag da vers\u00e3o do bug. Basta olhar a vers\u00e3o da \u00faltima tag no reposit\u00f3rio.</p>"},{"location":"contributing/#repositorio","title":"Reposit\u00f3rio","text":"<p>Github tupa</p>"},{"location":"examples/","title":"Exemplos","text":"<p>Em breve mais exemplos</p>"},{"location":"getting_started/","title":"Como funciona o registro de rotas","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Registro Simples</li> <li>Registro de mais rotas</li> </ul> <p></p>"},{"location":"getting_started/#registro-simples","title":"Registro simples","text":"<p>De forma simples, podemos instanciar uma rota ao chamar o m\u00e9todo <code>RegisterRoutes([]tupa.RouteInfo{routeInfo})</code>, que podemos acessar facilmente a partir do nosso servidor instanciado.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", nil)\n    routeInfo := tupa.RouteInfo{\n        Path:   \"/\",\n        Method: \"GET\",\n        Handler: func(c *tupa.TupaContext) error {\n            return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n        },\n    }\n    server.RegisterRoutes([]tupa.RouteInfo{routeInfo})\n\n    server.New()\n}\n</code></pre> <p>Agora em <code>http://localhost:6969/</code>iremos obter a mensagem \"Hello world! :D\".</p> <p>No Tup\u00e3, por padr\u00e3o todo handler deve receber um TupaContext e retornar um erro. Atrav\u00e9s do TupaContext voc\u00ea ser\u00e1 capaz de acessar diversas funcionalidades para a sua requisi\u00e7\u00e3o ser bem sucedida.</p> <p></p>"},{"location":"getting_started/#registro-de-mais-rotas","title":"Registro de mais rotas","text":"<p>Para fazer o registro de novas rotas, podemos simplesmente adicionar mais paths ao array <code>routeInfo</code></p> <pre><code>package main\n\nimport (\n    \"io\"\n    \"net/http\"\n\n    \"github.com/tupatech/tupa\"\n)\n\nfunc main() {\n    server := tupa.NewAPIServer(\":6969\", nil)\n    routeInfo := []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(*tc.Response(), http.StatusOK, \"Hello world! :D\")\n            },\n        },\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(c.Resp, resp.Body)\n                return err\n            },\n        },\n    }\n\n    server.RegisterRoutes(routeInfo)\n    server.New()\n}\n\n</code></pre> <p>Agora teremos os dois endpoints registrados, se <code>/</code>e <code>/cats</code>. Se formos em <code>http://localhost:6969/cat</code> vamos ver a foto de um \ud83d\udc08.</p> <p>Por\u00e9m, em uma aplica\u00e7\u00e3o real, precisamos manter uma arquitetura mais organizada do framework, para isso devemos usar os Routes Managers. </p>"},{"location":"global_after_middlewares/","title":"Criando Global After Middlewares","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Criando Global After Middleware</li> <li>Criando conjuntos de Global After Middlewares</li> </ul> <p>Em alguns momentos, vamos precisar executar middlewares ap\u00f3s a execu\u00e7\u00e3o de nossa requisi\u00e7\u00e3o e para isso precisamos usar Global AfterMiddlewares. O Tup\u00e3 oferece uma simples funcionalidade para executar os Global After Middlewares. Veja como criar um simples abaixo.</p>"},{"location":"global_after_middlewares/#criando-global-after-middlewares_1","title":"Criando Global After Middlewares","text":"<pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager)\n\n    server.UseGlobalAfterMiddleware(GlobalAfterMiddlewareTest, GlobalAfterMiddleware2)\n\n    server.New()\n}\n\nfunc GlobalAfterMiddlewareTest(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"GlobalAfterMiddlewareTest -&gt; midd after global\")\n        return next(c)\n    }\n}\n\nfunc GlobalAfterMiddleware2(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"GlobalAfterMiddleware2 -&gt; midd after global 2\")\n        return next(c)\n    }\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCatsCONJUNTOSROTAS}, noMiddlewaresRoutesManager)\n}\n\nfunc MiddlewareSampleCatsCONJUNTOSROTAS(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"MiddlewareSampleCats -&gt; midd conjuntos de rotas\")\n        return next(c)\n    }\n}\n\nfunc noMiddlewaresRoutesManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n            },\n        },\n    }\n}\n</code></pre> <p>Simples assim declaramos dois AfterMiddlewares com o Tup\u00e3. Agora tanto o <code>GlobalAfterMiddlewareTest</code> quanto <code>GlobalAfterMiddlewareTest</code> ser\u00e3o executados ap\u00f3s todos os outros middlewares e ap\u00f3s a requisi\u00e7\u00e3o tamb\u00e9m.</p>"},{"location":"global_middlewares/","title":"Criando Global Middlewares","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Criando Global Middlewares</li> </ul> <p>\u00c9 poss\u00edvel criar middlewares que s\u00e3o executados antes de todos os outros e que \u00e9 aplicado para todas as rotas. Podemos fazer isso com a fun\u00e7\u00e3o <code>UseGlobalMiddlewares</code>. Veja o exemplo abaixo de como usar.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager)\n\n    server.UseGlobalMiddlewares(GlobalMiddleware1)\n\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCatsCONJUNTOSROTAS}, noMiddlewaresRoutesManager)\n}\n\nfunc GlobalMiddleware1(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"GlobalMiddleware1 -&gt; midd global 1\")\n        return next(c)\n    }\n}\n\nfunc MiddlewareSampleCatsCONJUNTOSROTAS(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"MiddlewareSampleCats -&gt; midd conjuntos de rotas\")\n        return next(c)\n    }\n}\n\n</code></pre> <p>Dessa forma nosso middleware Global executou antes de todos os outros middlewares.</p> <p>Os middlewares s\u00e3o executados por ordem crescente, portanto ser\u00e3o executados do menor \u00edndice para o maior \u00edndice, o exemplo abaixo mostra como se deve usar m\u00faltiplos middlewares.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager)\n\n    server.UseGlobalMiddlewares(GlobalMiddleware1, GlobalMiddleware2)\n\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCatsCONJUNTOSROTAS}, noMiddlewaresRoutesManager)\n}\n\nfunc GlobalMiddleware1(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"GlobalMiddleware1 -&gt; midd global 1\")\n        return next(c)\n    }\n}\n\nfunc GlobalMiddleware2(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"GlobalMiddleware2 -&gt; midd global 2\")\n        return next(c)\n    }\n}\n\nfunc MiddlewareSampleCatsCONJUNTOSROTAS(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        slog.Info(\"MiddlewareSampleCats -&gt; midd conjuntos de rotas\")\n        return next(c)\n    }\n}\n</code></pre> <p>Acima vimos como criar middlewares que s\u00e3o executados antes de todos os outros, por\u00e9m v\u00e3o ter situa\u00e7\u00f5es que vamos precisar criar middlewares que devem ser executados depois de todos os outros middlewares e depois da requisi\u00e7\u00e3o em si. Para isso devemos usar os After Middlewares</p>"},{"location":"license/","title":"Licen\u00e7a","text":"<pre><code>MIT License\n\nCopyright (c) 2024 Victor Hugo Gabriel dos Reis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Middlewares simples</li> <li>Middlewares diferentes para Conjuntos de rotas</li> <li>Middlewares em conjuntos de rotas + especificos de rotas</li> </ul> <p>Usar middlewares no Tup\u00e3 \u00e9 muito f\u00e1cil, podemos implementar middlewares tanto a n\u00edvel de rota quando para conjuntos de rotas. </p> <p></p>"},{"location":"middlewares/#middlewares-simples","title":"Middlewares simples","text":"<p>Vamos adicionar um middleware simples a n\u00edvel de rota. Basta adicionar uma nova propriedade <code>Middlewares</code> dentro do objeto do endpoint.</p> <p>Vamos adicionar um middleware na rota <code>/cats</code>.</p> <pre><code>func main() {\n    routeManagerExample := func() {\n        routes := func() []tupa.RouteInfo {\n            return []tupa.RouteInfo{\n                {\n                    Path:   \"/\",\n                    Method: \"GET\",\n                    Handler: func(c *tupa.TupaContext) error {\n                        return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n                    },\n                },\n                {\n                    Path:   \"/cats\",\n                    Method: \"GET\",\n                    Handler: func(c *tupa.TupaContext) error {\n                        resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                        if err != nil {\n                            return err\n                        }\n                        defer resp.Body.Close()\n                        _, err = io.Copy(c.Resp, resp.Body)\n                        return err\n                    },\n                    Middlewares: []tupa.MiddlewareFunc{\n                        MiddlewareSampleCats,\n                    },\n                },\n            }\n        }\n\n        tupa.AddRoutes(nil, routes)\n    }\n\n    server := tupa.NewAPIServer(\":6969\", routeManagerExample)\n\n    server.RegisterRoutes(routeInfo)\n    server.New()\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        c.Resp.Header().Set(\"Content-Type\", \"image/jpeg\")\n        c.Resp.Header().Add(\"Referrer-Policy\", \"alguem interessado em gatos\")\n        return next(c)\n    }\n}\n</code></pre> <p>Podemos obter o resultado do middleware acima, basta apertar f12 e conferir a requisi\u00e7\u00e3o na aba Network do nosso devtools.</p> <p></p> <p></p>"},{"location":"middlewares/#conjuntos-de-rotas-com-middlewares-diferentes","title":"Conjuntos de rotas com middlewares diferentes","text":"<p>Mas pode ser que queremos adicionar middlewares diferentes para conjuntos de rotas diferentes. Nesse caso podemos armazenar nossas rotas em fun\u00e7\u00f5es e chamar o m\u00e9todo <code>GetRoutes()</code> do Tup\u00e3 como par\u00e2metro a fun\u00e7\u00e3o RegisterRoutes(). Veja um exemplo abaixo:</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager())\n    server.New()\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        c.Resp.Header().Set(\"Content-Type\", \"image/jpeg\")\n        c.Resp.Header().Add(\"Referrer-Policy\", \"alguem interessado em gatos\")\n        return next(c)\n    }\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(nil, SampleViewsManager)\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleViewsManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n            },\n        },\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(c.Resp, resp.Body)\n                return err\n            },\n        },\n    }\n}\n</code></pre> <p>Esse c\u00f3digo vai colocar nosso middleware como anteriormente, por\u00e9m agora est\u00e1 adicionando em um escopo maior, ao inv\u00e9s de ser um middleware de rota ele agora \u00e9 um middleware que age sobre um conjunto de rotas. Dessa forma podemos passar quantas rotas quisermos para um middleware espec\u00edfico.</p> <p></p>"},{"location":"middlewares/#middlewares-em-conjuntos-de-rotas-rota-especifica","title":"Middlewares em conjuntos de rotas + rota espec\u00edfica","text":"<p>Podemos tamb\u00e9m adicionar os middlewares para conjuntos de rotas e espec\u00edficos de rota juntos. Nesse caso a ordem ser\u00e1 que os especificos de rota ter\u00e3o preced\u00eancia sobre os de grupo na execu\u00e7\u00e3o. Vejamos no c\u00f3digo a seguir:</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager())\n    server.New()\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        fmt.Println(\"Printado depois\")\n        return next(c)\n    }\n}\n\nfunc MiddlewareSampleRoute(next tupa.APIFunc) tupa.APIFunc {\n    return func(c *tupa.TupaContext) error {\n        fmt.Println(\"Printado antes\")\n        c.Resp.Header().Set(\"Content-Type\", \"text/plain\")\n        c.Resp.Header().Add(\"Referrer-Policy\", \"alguem interessado em gatos\")\n        return next(c)\n    }\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(nil, SampleViewsManager)\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleViewsManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n            },\n        },\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(c.Resp, resp.Body)\n                return err\n            },\n            Middlewares: []tupa.MiddlewareFunc{MiddlewareSampleRoute},\n        },\n    }\n}\n</code></pre> <p>Ouput:</p> <pre><code>Servidor iniciado na porta: :6969\nPrintado antes\nPrintado depois\n</code></pre> <p>Por\u00e9m, em alguns casos vamos precisar armazenar algum dado ap\u00f3s qualquer requisi\u00e7\u00e3o for conclu\u00edda e ap\u00f3s todos conjuntos de AfterMiddlewares, para isso devemos usar os Middlewares Globais</p>"},{"location":"params/","title":"Params e Query Params","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Param(): Obtendo o par\u00e2metro da requisi\u00e7\u00e3o</li> <li>QueryParam(): Obtendo unico Query Param</li> <li>QueryParams(): Obtendo m\u00faltiplos Query Params</li> </ul> <p>O Tup\u00e3 te fornece as fun\u00e7\u00f5es necess\u00e1rias tanto para obter os par\u00e2metros da requisi\u00e7\u00e3o, quanto os query parameters.</p> <p>Para isso voc\u00ea pode usar as fun\u00e7\u00f5es <code>Param(param)</code>, <code>QueryParam()</code>, <code>QueryParams()</code>.</p> <p></p>"},{"location":"params/#obtendo-o-parametro-da-requisicao","title":"Obtendo o par\u00e2metro da requisi\u00e7\u00e3o","text":"<p>Para obter facilmente o par\u00e2metro da requisi\u00e7\u00e3o. Para isso colocamos o nome do par\u00e2metro na url, usando a sintaxe <code>/{param}</code>, depois disso podemos chamar a fun\u00e7\u00e3o <code>Param(param)</code> dispon\u00edvel a partir do TupaContext.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/{jwt}\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                param := tc.Param(\"jwt\")\n                tc.SendString(fmt.Sprintf(\"jwt:, %s\", param))\n\n                return nil\n            },\n        },\n    }\n}\n</code></pre> <p>Agora em <code>http://localhost:6969/&lt;parametro&gt;</code>, vamos obter o par\u00e2metro correto da requisi\u00e7\u00e3o:</p> <p></p> <p></p>"},{"location":"params/#obtendo-query-param-da-requisicao","title":"Obtendo Query Param da requisi\u00e7\u00e3o","text":"<p>Da mesma forma podemos obter o Query Param (\u00fanico), com o m\u00e9todo <code>QueryParam()</code>. Esse m\u00e9todo vai retornar um par\u00e2metro especifico da nossa URL, ent\u00e3o se especificarmos diversos par\u00e2metros, ele vai retornar s\u00f3 o que especificado.</p> <p>Vamos definir uma rota chamada /param, e vamos fazer a chamada usando Query Parameter, dessa forma o fim da url vai ficar <code>/param?&lt;nome_param&gt;=&lt;valor_param&gt;</code></p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/param\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                param := tc.QueryParam(\"jwt\")\n                tc.SendString(fmt.Sprintf(\"jwt: %s\", param))\n\n                return nil\n            },\n        },\n    }\n}\n</code></pre> <p>Vamos fazer uma GET request para a url <code>http://localhost:6969/param?jwt=eyJhbGciOiJIUzI1NiJ9.eyJSb2xlIjoiQWRtaW4iLCJJc3N1ZXIiOiJJc3N1ZXIiLCJVc</code>.</p> <p>Output:</p> <p></p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/param\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                param := tc.QueryParam(\"jwt\")\n                tc.SendString(fmt.Sprintf(\"jwt: %s\", param))\n\n                return nil\n            },\n        },\n    }\n}\n\n</code></pre> <p></p> <ul> <li>Como foi dito anteriormente, se passado mais de um par\u00e2metro, esse m\u00e9todo vai pegar s\u00f3 o que foi especificado no argumento. Podemos conferir essa funcionalidade.</li> </ul> <p>Vamos passar 2 argumentos na URL, e fazer uma requisi\u00e7\u00e3o para <code>http://localhost:6969/param?jwt=eyJhbGciOiJIUzI1NiJ9.eyJSb2x&amp;name=victor</code></p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/param\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                param := tc.QueryParam(\"name\")\n                tc.SendString(fmt.Sprintf(\"name: %s\", param))\n\n                return nil\n            },\n        },\n    }\n}\n</code></pre> <p>Output:</p> <p></p> <p></p>"},{"location":"params/#obtendo-multiplos-query-params-da-requisicao","title":"Obtendo M\u00faltiplos Query Params da requisi\u00e7\u00e3o","text":"<p>Podemos obter facilmente diversos Query Params da nossa requisi\u00e7\u00e3o usando o m\u00e9todo <code>QueryParams()</code>, esse m\u00e9todo vai nos retornar um <code>map[string][]string</code>, ou seja <code>parametro: [valores]</code>.</p> <p>Vamos fazer a mesma chamada para <code>http://localhost:6969/param?jwt=eyJhbGciOiJIUzI1NiJ9.eyJSb2x&amp;name=victor</code></p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/param\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                param := tc.QueryParams()\n                tc.SendString(fmt.Sprintf(\"params: %s\", param))\n\n                return nil\n            },\n        },\n    }\n}\n</code></pre> <p>Output: </p>"},{"location":"routes_manager/","title":"Criando Routes Managers","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Criando Route Manager</li> <li>Criando conjuntos de route Manager</li> </ul> <p>  ## Criando Route Manager  Podemos passar nossas rotas dentro de fun\u00e7\u00f5es e passa-las como par\u00e2metro para a fun\u00e7\u00e3o <code>NewAPIServer</code>. O segundo par\u00e2metro dela deve receber uma fun\u00e7\u00e3o que vai instanciar quantas rotas quisermos. Veja o exemplo abaixo.</p> <pre><code> func main() {\n    routeManagerExample := func() {\n        routes := func() []tupa.RouteInfo {\n            return []tupa.RouteInfo{\n                {\n                    Path:   \"/\",\n                    Method: \"GET\",\n                    Handler: func(c *tupa.TupaContext) error {\n                        return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n                    },\n                },\n                {\n                    Path:   \"/cats\",\n                    Method: \"GET\",\n                    Handler: func(c *tupa.TupaContext) error {\n                        resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                        if err != nil {\n                            return err\n                        }\n                        defer resp.Body.Close()\n                        _, err = io.Copy(c.Resp, resp.Body)\n                        return err\n                    },\n                },\n            }\n        }\n\n        tupa.AddRoutes(nil, routes)\n    }\n\n    server := tupa.NewAPIServer(\":6969\", routeManagerExample)\n\n    server.New()\n}\n</code></pre> <p>No exemplo acima, passamos todas nossas j\u00e1 dentro do NewAPIServer, teremos tanto a rota <code>/</code>quando a <code>/cats</code>.</p> <p>  ## Route Manager Conjunto rotas</p> <p>Podemos tamb\u00e9m criar Route Managers para adicionarmos conjuntos de rotas. Veja o exemplo abaixo:</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\", exampleManager)\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCatsCONJUNTOSROTAS}, noMiddlewaresRoutesManager)\n}\n\nfunc noMiddlewaresRoutesManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(c.Resp, http.StatusOK, \"Hello world! :D\")\n            },\n        },\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(c *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(c.Resp, resp.Body)\n                return err\n            },\n        },\n    }\n}\n</code></pre> <p>Dessa forma teremos do mesmo jeito as duas rotas, por\u00e9m nossa func main() fica menos polu\u00edda, e poderemos administrar conjuntos de rotas de forma mais organizada e controlada, isso vai permitir que usemos nossos middlewares mantendo uma boa arquitetura do nosso c\u00f3digo. </p>"}]}